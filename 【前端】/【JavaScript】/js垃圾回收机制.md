**自动内存管理（垃圾回收）阵营：**

JavaScript、Java、Go、Python、PHP、Ruby、C#

**手动内存管理阵营：**

C、C++、Rust

> 如果任由内存泄漏，会让系统变卡甚至崩溃。导致这问题的原因是 JavaScript 的引擎 V8 只能使用一部分内存，
>
> 具体来说，在 64 位系统下，V8 最多只能分配 1.4G；在 32 位系统中，最多只能分配 0.7G

JavaScript 的数据类型可分为**基本类型**和**引用类型**

![img](D:\Markdown\图片\v2-c0f6cd629d0eb7159619184bfb883835_720w.webp)



> 虽然说 JavaScript 的动态性很是方便，但是如果一些新手修改了对象类型的值而不告知，那么就成了灾难。
>
> 因为动态性+全局作用域，所有变量命名就成了问题，所以一般的库都是用IIFE、闭包等方法破局，
>
> 再后面就有了模块化（ES module）的概念，其本质是为了解决变量命名、语言动态性的问题
>
> 在 JavaScript 中，引擎需要用栈来维护程序执行时的上下文状态（即执行上下文），
>
> 如果栈空间大了的话，所有数据存放在栈空间中，会影响到上下文切换的效率，从而影响整个程序的执行效率，
>
> 所以占内存大的数据会放在堆空间中，引用它的地址来表示这个变量

### **堆内存的分类**

一个 V8 进程的内存通常由以下部分组成

- 新生代内存区（new space）
- 老生代内存区（old space）
- 大对象区（large object space）
- 代码区（code space）
- map 区（map space）

关键是新生代（内存）和老生代（内存）。针对新生代和老生代，引擎采用了两种不同的垃圾回收机制



## **新生代与老生代的垃圾回收**

在介绍两种垃圾回收机制前，要先知道两个知识点：**代际假说**和**分代收集**

代际假说有以下两个特点：

- 大部分对象在内存中存活的时间很短，简单说，就是很多对象一经分配内存，很快就变得不可访问
- 不死的对象，会活得更久

因为有代际假说的认知，所以我们在垃圾回收时，会根据对象不同的生存周期采用不同的算法，

其中 V8 把堆内存分为新生代和老生代两个区域（其他几个区域用处不大）

**新生代中存放生存时间短的对象，老生代存放生存时间久的对象**

为此，新生代区通常只支持1~8M 的容量，而老生代区会支持更大的容量，而针对这两块区域，V8 分别使用两个不同的垃圾回收器

- **主垃圾回收器**，负责老生代的垃圾回收
- **副垃圾回收器**，负责新生代的垃圾回收

我们先说说副垃圾回收器时如何处理垃圾回收的

### **新生代内存回收**

新生代采用的是 Scavenge 算法，是把新生代空间对半分为两个区域，一半是对象区域（from），一半是空闲区域（to）。如下图所示：

![img](D:\Markdown\图片\v2-5d90683202ee91166024cef4e158f5b5_720w.webp)

新的对象会首先被分配到对象（from）空间，当对象区域快写满时，就需要执行一次垃圾清理操作。

当进行垃圾收回时，先将 from 空间中存活的对象复制到空闲（to）空间进行保存，对未存活的空间进行回收。

复制完成后，对象空间和空闲空间进行角色调换，空闲空间变成新的对象空间，原来的对象空间则变成空闲空间。

这样就完成了垃圾对象的回收操作，同时这种角色调换的操作能让新生代中的这两块区域无限重复使用下去

![img](D:\Markdown\图片\v2-ba1ae480cc0a1382e0b607ba92cabe75_720w.webp)

**当一个对象在两次变换中还存在时，就会从新生代区”晋升“到”老生代区“。这一过程被称为对象晋升策略**

### **老生代内存回收**

主垃圾回收器负责老生代区的垃圾回收。其中的对象包括**新生代区”晋升“的对象和一些大的对象**。

因此老生代区中的对象有两个特点，**对象占用空间大，对象存活时间长**

它不会像新生代区那样使用 Scavenge 算法，因为复制大对象所花费的时间长，执行效率并不高。

所以它采用标记 - 清除（Mark - Sweep）进行垃圾回收

简单来说，先标记，然后清除，但是内存空间里的对象还是不连续，所以引入整理。

这就是老生代区的垃圾回收过程 **标记 - 清除 - 整理**。先标记哪些是要回收的变量，再进行回收（清除），然后将内存空间整理（到一边），这样空间就大了

![img](D:\Markdown\图片\v2-33f352d7ded14073b6fbf83a8b90dad5_720w.webp)

#### **增量标记算法**

因为老生代区的对象相对大，虽然采用”标记-清除“算法会比 Scavenge 更快，但架不住卡顿问题。

为什么会卡顿？因为 JavaScript 是单线程。

为此，V8 将标记过程分为一个个子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，

![img](D:\Markdown\图片\v2-8caeb00451623c091f96f52e824da166_720w.webp)

而这一行为，与 React Fiber 的设计思路类似，将大人物分割成小任务，因为小，所以执行快，让人察觉不到卡顿

### **新生代 VS 老生代**

- 新生代垃圾回收是临时分配的内存，存活时间短；老生代垃圾回收是常驻内存，存活时间长

- 新生代垃圾回收由副垃圾回收器负责；老生代垃圾回收由主垃圾回收器负责

- 新生代采用 Scavenge 算法；老生代采用「标记-清除」算法

- - Scavenge 算法：将空间分为两半，一半是 from 空间，一半是 to 空间。新加入的对象会放在 from 空间，当空间快满时，执行垃圾清理；再角色调换，再当调换完后的 from 空间快蛮时，再执行垃圾清理，如此反复

  - 标记-清理-整理：此为两个算法，「标记-清理」算法和 「标记-整理」算法

  - - 标记-清理：标记用不到的变量，清理掉
    - 标记-整理：清理完内存后，会产生不连续的内存空间，为节省空间，整理算法会将内存排序到一处空间，空间就变大了











