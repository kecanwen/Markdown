```js
let count = 1;
let timer = setTimeout( () => {
    console.log(3);
},3000)
console.log(count);
```

通过这段代码，我相信大家都知道打印顺序和结果应该是1等待三秒后打印3，其实这就是异步。

其实在这里存在一个我们看不见的任务队列，存放着它需要默默执行的命令

想要了解其中的执行机制，那就要浅尝一下计算机原理和浏览器原理啦

### 进程和线程

**计算机原理**：进程和线程

**进程**是CPU资源分配的最小单位，**线程**是CPU调度的最小单位

如下图所示

![img](D:\Markdown\图片\v2-d90673018935e52fae138ed52f02bd78_720w.webp)

进程线程图

例如在我们口罩期间，上面下发命令要求居委会成员为小区中每家每户做核酸检测，居委的工作人员要去自己本小区的仓库中去找相应的资源，然后再对住户进行核酸检测。

在这个例子中，小区就是进程，居委的工作人员就是线程。小区a只能去用小区a仓库中的东西，而不能去用小区b、小区c仓库里面的东西。也就是说进程中的资源是共享的以供线程去调度使用，并且进程和进程之间的资源是独立的。

### 面试题：

1、浏览器新开一个窗口，tab页是进程还是线程？

答案：进程（从区别概念上出发，去分析）

继续发散问题：每个tab是不同的进程

方向一：窗口（进程间）通信？

浏览器的存储 - storage、cookie => 多种存储的区别

方向二：浏览器原理，如下图

![img](D:\Markdown\图片\v2-bce4c71ef2cb0ed30bd099568d3d52e0_720w.webp)

浏览器原理

事件触发线程相当于最终执行者的角色存在，按照自己的执行逻辑进行执行，然后将其添加到任务队尾，最后交予 JS 引擎

来一道题：

```js
while(true) {
            console.log(1);
        }
```

执行结果就是页面卡住了，空白然后我们的电脑风扇就在疯狂的转，其实原理就是 JS 引擎在不断的入栈执行，入栈执行，然后导致爆栈，GUI 引擎被阻断，导致浏览器卡死

2、执行顺序题：

```js
setTimeout(() => {
    console.log('settimeout');
});
new Promise((resolve, reject) => {
    resolve(111)
}).then(res => {
    console.log('promise')
})
console.log('begin');
```

输出顺序:begin promise settimeout

这样的输出顺序的主要原因就是因为任务在两个层面进行区分：宏任务和微任务以及同步任务和异步任务，详解看下图

![img](D:\Markdown\图片\v2-13e9bfce6a74ae8ebdaa4d2ea840dd2f_720w.webp)

event loop

总结：setTimeout（横向分析是宏任务，纵向分析是一个异步任务）、Promise.then()（横向分析是一个微任务，纵向分析是一个异步任务）、console.log(横向分析是宏任务，纵向分析是同步任务)。首先执行宏任务同步任务console.log，依次是setTimeout，虽说是宏任务但是它还是异步任务，所以被放到 event queue 任务队列中处于 pending 状态，然后宏任务执行完毕去执行 Promise.then() 微任务,微任务执行完成之后主线程被清空，然后去回调我们 event queue 。（宏任务有一部分是立即执行的还有一部分是放在 event queue 中，宏任务执行完毕之后，一句话总结：有微则微，无微则宏）

附带一道测试题叭！！！

```js
        console.log(0);
        new Promise(resolve => {
            console.log(1)
            resolve()
        })
        then(() => {
            console.log(2)
        })
        console.log(3);
        setTimeout(() => {
            console.log(4);
        }, 0)
        new Promise((resolve, reject) => {
            console.log(5);
            resolve()
        }).then(() => {
            console.log(6)
        })
        console.log(7);
```

打印结果：0 1 3 5 7 2 6 4

解析：首先执行同步任务，setTimeout虽然是宏任务但是纵向分析是异步任务（添加到 event queue 中，其处于pending），Promise 中的入参是同步任务直接执行，.then() 回调是一个异步任务（微任务），所以执行顺序就是先执行同步任务，打印 0 1 3 然后遇到 setTimeout，被添加到事件队列中还处于pending 状态（即使它的延时是0）然后是 5 7，宏任务执行完毕之后去执行微任务，在任务队列中保持先进先出的特性，执行顺序就是 2 6，微任务执行完成之后主线程被清空，最后执行回调 event queue 中的 setTimeout 打印 4