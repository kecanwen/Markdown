#  `AND` or `OR` 这两个关键字来组装多个条件

（表示并且，或者） (ie. num_wheels >= 4 AND doors <= 2 这个组合表示 num_wheels属性 大于等于 4 并且 doors 属性小于等于 2). 下面的具体语法规则，可以用来筛选数字属性列（包括 整数，浮点数） :

| Operator（关键字）  | Condition（意思）                                            | SQL Example(例子）           |
| ------------------- | ------------------------------------------------------------ | ---------------------------- |
| =, !=, < <=, >, >=  | Standard numerical operators 基础的 大于，等于等比较         | col_name != 4                |
| BETWEEN … AND …     | Number is within range of two values (inclusive) 在两个数之间 | col_name BETWEEN 1.5 AND10.5 |
| NOT BETWEEN … AND … | Number is not within range of two values (inclusive) 不在两个数之间 | col_name NOT BETWEEN 1 AND10 |
| IN (…)              | Number exists in a list 在一个列表                           | col_name IN (2, 4, 6)        |
| NOT IN (…)          | Number does not exist in a list 不在一个列表                 | col_name NOT IN (1, 3, 5)    |

越是精确的条件筛选，会让结果更容易理解，同时因为条件在返回之前筛掉不必要的结果，SQL的运行速度也会快很多（想象一下你只是想看下最近有哪些大片上映，你没必要下载整个电影看一遍）.





# LIKE（模糊查询） 和 %（通配符） 

是新增的两个. 下面这个表格对字符串操作符有详细的描述:

| Operator（操作符） | Condition（解释）                                            | Example（例子）                                              |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| =                  | Case sensitive exact string comparison (*notice the single equals*)完全等于 | col_name = "abc"                                             |
| != or <>           | Case sensitive exact string inequality comparison 不等于     | col_name != "abcd"                                           |
| LIKE               | Case insensitive exact string comparison 没有用通配符等价于 = | col_name LIKE "ABC"                                          |
| NOT LIKE           | Case insensitive exact string inequality comparison 没有用通配符等价于 != | col_name NOT LIKE"ABCD"                                      |
| %                  | Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) 通配符，代表匹配0个以上的字符 | col_name LIKE "%AT%" (matches "AT", "ATTIC", "CAT" or even "BATS") "%AT%" 代表AT 前后可以有任意字符 |
| _                  | Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) 和% 相似，代表1个字符 | col_name LIKE "AN_" (matches "AND", but not "AN")            |
| IN (…)             | String exists in a list 在列表                               | col_name IN ("A", "B", "C")                                  |
| NOT IN (…)         | String does not exist in a list 不在列表                     | col_name NOT IN ("D", "E", "F")                              |





# 查询结果Filtering过滤 和 sorting排序

```
DISTINCT` 语法介绍，我们拿之前的 Movies表来说，可能很多电影都是同一年Year发布的，如果你想要按年份排重，一年只能出现一部电影到结果中， 你可以用 `DISTINCT` 关键字来指定某个或某些属性列唯一返回。写作：`DISTINCT Year
```

选取出唯一的结果的语法

```
SELECT **DISTINCT** column, another_column, … FROM mytable WHERE *condition(s)*;
```

因为 `DISTINCT` 语法会直接删除重复的行, 我们还会学习 `GROUP BY` 语句， `GROUP BY` 也会返回唯一的行，不过可以对具有相同的 属性值的行做一些统计计算，比如：求和.

##### 结果排序 （Ordering results）

在实际的数据表中，数据添加的时候不是完全顺序的，比如我们实际的Dog表，不会是按狗的身高从小到大去添加数据，当数据量成千上万之后，如果结果不做任何排序，结果会看起来很错乱.

为了解决结果排序问题, 我们可以用 `ORDER BY col_name `排序的语法来让结果按一个或多个属性列做排序.

结果排序（ordered results）

```
SELECT column, another_column, … FROM mytable WHERE *condition(s)* **ORDER BY column ASC/DESC**;
```

`ORDER BY col_name` 这句话的意思就是让结果按照 col_name 列的具体值做 ASC升序 或 DESC 降序，对数字来说就是升序 1，2，3，... 或降序 ... 3,2,1 . 对于文本列，升序和降序指的是按文本的字母序。

##### 通过Limit选取部分结果

`LIMIT` 和 `OFFSET` 子句通常和`ORDER BY` 语句一起使用，当我们对整个结果集排序之后，我们可以 `LIMIT`来指定只返回多少行结果 ,用 `OFFSET`来指定从哪一行开始返回。你可以想象一下从一条长绳子剪下一小段的过程，我们通过 `OFFSET` 指定从哪里开始剪，用 `LIMIT` 指定剪下多少长度。





# 用JOINs进行多表联合查询



到目前为止我们已经学会了如何做一个单表的查询，但是在现实数据库中往往包含一组相关的数据表，这些表一般会符合数据库范式*(normalization)*[[1\]](http://en.wikipedia.org/wiki/Database_normalization). 让我们先了解下关系数据库的`范式`

##### 数据库范式(normalization)

数据库范式是数据表设计的规范，在范式规范下，数据库里每个表存储的重复数据降到最少（这有助于数据的一致性维护），同时在数据库范式下，表和表之间不再有很强的数据耦合，可以独立的增长 (ie. 比如汽车引擎的增长和汽车的增长是完全独立的). 范式带来了很多好处，但随着数据表的分离，意味着我们要查询多个数据属性时，需要更复杂的SQL语句，也就是本节开始介绍的多表连接技术。这样SQL的性能也会面临更多的挑战，特别是当大数据量的表很多的情况下.

如果一个实体（比如Dog）的属性数据被分散到多个数据表中，我们就需要学习如何通过 `JOIN`连表技术来整合这些数据并找到我们想要查询的数据项.

##### 用JOINs进行多表联合查询

`主键(primary key)`, 一般关系数据表中，都会有一个属性列设置为 `主键(primary key)`。主键是唯一标识一条数据的，不会重复复（想象你的身份证号码)。一个最常见的主键就是auto-incrementing integer(自增ID，每写入一行数据ID+1, 当然字符串，hash值等只要是每条数据是唯一的也可以设为主键.

借助`主键(primary key)`（当然其他唯一性的属性也可以），我们可以把两个表中具有相同 主键ID的数据连接起来（因为一个ID可以简要的识别一条数据，所以连接之后还是表达的同一条数据）（你可以想象一个左右连线游戏）。具体我们用到 `JOIN` 关键字。我们先来学习 `INNER JOIN`.

用INNER JOIN 连接表的语法

```sql
SELECT column, another_table_column, … FROM mytable （主表） INNER JOIN another_table （要连接的表）    ON mytable.id = another_table.id (想象一下刚才讲的主键连接，两个相同的连成1条) WHERE *condition(s)* ORDER BY column, … ASC/DESC LIMIT num_limit OFFSET num_offset;
```

通过`ON`条件描述的关联关系;`INNER JOIN` 先将两个表数据连接到一起. 两个表中如果通过ID互相找不到的数据将会舍弃。此时，你可以将连表后的数据看作两个表的合并，SQL中的其他语句会在这个合并基础上 继续执行（想一下和之前的单表操作就一样了）. 
还有一个理解`INNER JOIN`的方式，就是把 `INNER JOIN` 想成两个集合的交集。![img](D:\Markdown\图片\0b46f21fbe096b639ff3bd4b0b338744eaf8acc7.png)

> **小贴士:**
>
> `INNER JOIN` 可以简写做 `JOIN`. 两者是相同的意思，但我们还是会继续写作 `INNER JOIN` 以便和后面的`LEFT JOIN`， `RIGHT JOIN`等相比较.





# 外连接（OUTER JOINs）

`INNER JOIN` 只会保留两个表都存在的数据（还记得之前的交集吗），这看起来意味着一些数据的丢失，在某些场景下会有问题.

真实世界中两个表存在差异很正常，所以我们需要更多的连表方式，也就是本节要介绍的

- 左连接`LEFT JOIN`  表A 连接 B, `LEFT JOIN`保留A的所有行，不管有没有能匹配上B
- 右连接`RIGHT JOIN`  保留所有B里的行
- 全连接`FULL JOIN`   不管有没有匹配上，同时保留A和B里的所有行

这几个 连接方式都会保留不能匹配的行。

用LEFT/RIGHT/FULL JOINs 做多表查询

```sql
SELECT column, another_column, … FROM mytable **INNER/LEFT/RIGHT/FULL JOIN another_table    ON mytable.id = another_table.matching_id** WHERE *condition(s)* ORDER BY column, … ASC/DESC LIMIT num_limit OFFSET num_offset;
```



**我们还是可以用集合的图示来描述：**
			

​	`LEFT JOIN` ![img](D:\Markdown\图片\leftjoin.png) 
​		`RIGHT JOIN` 反过来 ![img](D:\Markdown\图片\rightjoin.png) 
`			FULL JOIN` ![img](D:\Markdown\图片\fulljoin.jpeg) 

将两个表数据1-1连接，保留A或B的原有行，如果某一行在另一个表不存在，会用 NULL来填充结果数据。所有在用这三个JOIN时，你需要单独处理 `NULL`. 

> 小贴士:
>
> 这些Join也可以写作 `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`, 或 `FULL OUTER JOIN`, 和 `LEFT JOIN`, `RIGHT JOIN`, and `FULL JOIN` 等价.



# **关于特殊关键字 NULL**



在数据库中，`NULL`表达的是 "无"的概念，或者说没有东西。

因为 NULL的存在，我们需要在编写SQL时考虑到某个属性列可能是 NULL的情况， 这种特殊性会造成编写SQL的复杂性，

所以没有必要的情况下，我们应该尽量减少 `NULL`的使用，让数据中尽可能少出现 `NULL`的情况。

如果某个字段你没有填写到数据库，很可能就会出现`NULL` 。

所有一个常见的方式就是为字段设置`默认值`,比如 数字的默认值设置为0，字符串设置为 ""字符串. 

但是在一些`NULL` 表示它本来含义的场景，需要注意是否设置默认值还是保持`NULL`。 

**(比如, 当你计算一些行的平均值的时候，如果是0会参与计算导致平均值差错，是`NULL`则不会参与计算**).

还有一些情况很难避免 `NULL` 的出现, 比如之前说的 outer-joining 多表连接，A和B有数据差异时，必须用 `NULL` 来填充。

这种情况，可以用`IS NULL`和 `IS NOT NULL` 来选在某个字段是否等于 `NULL`.

在查询条件中处理 NULL

```sql
SELECT column, another_column, … FROM mytable WHERE column IS/IS NOT NULL AND/OR another_condition AND/OR …;
```



# **在查询中使用表达式**

























